<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Block Game - Aishi Games</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Arial', sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: white;
      }

      .game-container {
        text-align: center;
        background: rgba(0, 0, 0, 0.3);
        padding: 30px;
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      }

      h1 {
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-size: 2.5rem;
      }

      .game-info {
        display: flex;
        justify-content: space-around;
        margin-bottom: 20px;
        font-size: 1.2rem;
      }

      .info-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px 20px;
        border-radius: 10px;
        transition: all 0.3s ease;
      }

      .info-item.pulse {
        animation: pulse 0.5s ease;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.15);
          background: rgba(255, 215, 0, 0.3);
        }
      }

      .score-popup {
        position: fixed;
        font-size: 2rem;
        font-weight: bold;
        color: #ffd700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        z-index: 1000;
        animation: scoreFloat 1s ease-out forwards;
      }

      @keyframes scoreFloat {
        0% {
          opacity: 1;
          transform: translateY(0) scale(0.5);
        }
        50% {
          transform: translateY(-30px) scale(1.2);
        }
        100% {
          opacity: 0;
          transform: translateY(-60px) scale(1);
        }
      }

      .combo-text {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 3rem;
        font-weight: bold;
        color: #ff00ff;
        text-shadow: 0 0 20px #ff00ff, 2px 2px 4px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        z-index: 1001;
        animation: comboAnimation 1s ease-out forwards;
      }

      @keyframes comboAnimation {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.5) rotate(-10deg);
        }
        50% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1.3) rotate(5deg);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.8) rotate(0deg);
        }
      }

      #gameCanvas {
        border: 3px solid white;
        background: #1a1a2e;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        display: block;
        margin: 0 auto;
      }

      .controls {
        margin-top: 20px;
        padding: 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
      }

      .controls h3 {
        margin-bottom: 10px;
      }

      .controls p {
        margin: 5px 0;
        font-size: 0.9rem;
      }

      button {
        margin-top: 20px;
        padding: 15px 40px;
        font-size: 1.2rem;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid white;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      button:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
      }

      .game-over {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        z-index: 1000;
      }

      .game-over h2 {
        font-size: 3rem;
        margin-bottom: 20px;
        color: #ff6b6b;
      }

      .back-link {
        display: inline-block;
        margin-top: 20px;
        color: white;
        text-decoration: none;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        transition: all 0.3s ease;
      }

      .back-link:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      /* Mobile Controls */
      .mobile-controls {
        display: none;
        margin-top: 20px;
        gap: 10px;
      }

      @media (max-width: 768px) {
        .mobile-controls {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          grid-template-rows: repeat(3, 80px);
          max-width: 300px;
          margin: 20px auto;
        }

        .controls {
          display: none;
        }

        .game-container {
          padding: 15px;
        }

        h1 {
          font-size: 1.8rem;
        }
      }

      .control-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid white;
        border-radius: 10px;
        color: white;
        font-size: 1.5rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        touch-action: manipulation;
        user-select: none;
      }

      .control-btn:active {
        background: rgba(255, 255, 255, 0.4);
        transform: scale(0.95);
      }

      .btn-left {
        grid-column: 1;
        grid-row: 2;
      }
      .btn-right {
        grid-column: 3;
        grid-row: 2;
      }
      .btn-rotate {
        grid-column: 2;
        grid-row: 1;
      }
      .btn-down {
        grid-column: 2;
        grid-row: 2;
      }
      .btn-drop {
        grid-column: 2;
        grid-row: 3;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>üü¶ Block Game</h1>

      <div class="game-info">
        <div class="info-item">
          <strong>Score:</strong> <span id="score">0</span>
        </div>
        <div class="info-item">
          <strong>Lines:</strong> <span id="lines">0</span>
        </div>
        <div class="info-item">
          <strong>Level:</strong> <span id="level">1</span>
        </div>
      </div>

      <canvas id="gameCanvas" width="300" height="600"></canvas>

      <!-- Mobile Touch Controls -->
      <div class="mobile-controls">
        <button
          class="control-btn btn-rotate"
          ontouchstart="handleRotate(event)"
        >
          ‚Üª
        </button>
        <button
          class="control-btn btn-left"
          ontouchstart="handleMoveLeft(event)"
        >
          ‚Üê
        </button>
        <button
          class="control-btn btn-down"
          ontouchstart="handleMoveDown(event)"
        >
          ‚Üì
        </button>
        <button
          class="control-btn btn-right"
          ontouchstart="handleMoveRight(event)"
        >
          ‚Üí
        </button>
        <button
          class="control-btn btn-drop"
          ontouchstart="handleHardDrop(event)"
        >
          ‚¨á
        </button>
      </div>

      <div class="controls">
        <h3>üéÆ Controls</h3>
        <p>‚Üê ‚Üí : Move Left/Right</p>
        <p>‚Üë : Rotate</p>
        <p>‚Üì : Soft Drop</p>
        <p>Space : Hard Drop</p>
      </div>

      <button id="startBtn" onclick="startGame()">Start Game</button>
      <button id="pauseBtn" onclick="togglePause()" style="display: none">
        Pause
      </button>

      <a href="../../index.html" class="back-link">‚Üê Back to Home</a>
    </div>

    <div class="game-over" id="gameOver">
      <h2>Game Over!</h2>
      <p style="font-size: 1.5rem">
        Final Score: <span id="finalScore">0</span>
      </p>
      <p style="font-size: 1.2rem">Lines: <span id="finalLines">0</span></p>
      <button onclick="restartGame()">Play Again</button>
    </div>

    <script>
      const canvas = document.getElementById('gameCanvas')
      const ctx = canvas.getContext('2d')
      const scoreElement = document.getElementById('score')
      const linesElement = document.getElementById('lines')
      const levelElement = document.getElementById('level')

      const COLS = 10
      const ROWS = 20
      const BLOCK_SIZE = 30

      let board = []
      let score = 0
      let lines = 0
      let level = 1
      let gameLoop
      let isPaused = false
      let isGameOver = false
      let dropCounter = 0
      let dropInterval = 1000
      let lastTime = 0

      // Tetromino shapes
      const SHAPES = [
        [[1, 1, 1, 1]], // I
        [
          [1, 1],
          [1, 1],
        ], // O
        [
          [0, 1, 0],
          [1, 1, 1],
        ], // T
        [
          [1, 1, 0],
          [0, 1, 1],
        ], // S
        [
          [0, 1, 1],
          [1, 1, 0],
        ], // Z
        [
          [1, 0, 0],
          [1, 1, 1],
        ], // L
        [
          [0, 0, 1],
          [1, 1, 1],
        ], // J
      ]

      const COLORS = [
        '#00f0f0', // I - Cyan
        '#f0f000', // O - Yellow
        '#a000f0', // T - Purple
        '#00f000', // S - Green
        '#f00000', // Z - Red
        '#f0a000', // L - Orange
        '#0000f0', // J - Blue
      ]

      let currentPiece = null
      let currentX = 0
      let currentY = 0

      function initBoard() {
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(0))
      }

      function drawBlock(x, y, color) {
        ctx.fillStyle = color
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)
        ctx.strokeStyle = '#000'
        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)
      }

      function drawBoard() {
        ctx.fillStyle = '#1a1a2e'
        ctx.fillRect(0, 0, canvas.width, canvas.height)

        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (board[y][x]) {
              drawBlock(x, y, board[y][x])
            }
          }
        }
      }

      function drawPiece() {
        if (!currentPiece) return

        const shape = SHAPES[currentPiece.type]
        const color = COLORS[currentPiece.type]

        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
              drawBlock(currentX + x, currentY + y, color)
            }
          }
        }
      }

      function createPiece() {
        const type = Math.floor(Math.random() * SHAPES.length)
        currentPiece = { type }
        currentX = Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2)
        currentY = 0

        if (collision()) {
          gameOver()
        }
      }

      function collision() {
        const shape = SHAPES[currentPiece.type]
        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
              const newX = currentX + x
              const newY = currentY + y

              if (newX < 0 || newX >= COLS || newY >= ROWS) {
                return true
              }
              if (newY >= 0 && board[newY][newX]) {
                return true
              }
            }
          }
        }
        return false
      }

      function merge() {
        const shape = SHAPES[currentPiece.type]
        const color = COLORS[currentPiece.type]

        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
              board[currentY + y][currentX + x] = color
            }
          }
        }
      }

      function rotate() {
        const shape = SHAPES[currentPiece.type]
        const rotated = shape[0].map((_, i) =>
          shape.map((row) => row[i]).reverse()
        )
        const previousType = currentPiece.type

        SHAPES[currentPiece.type] = rotated

        if (collision()) {
          SHAPES[currentPiece.type] = shape // Undo rotation
        }
      }

      function moveDown() {
        currentY++
        if (collision()) {
          currentY--
          merge()
          clearLines()
          createPiece()
        }
        dropCounter = 0
      }

      function moveLeft() {
        currentX--
        if (collision()) {
          currentX++
        }
      }

      function moveRight() {
        currentX++
        if (collision()) {
          currentX--
        }
      }

      function hardDrop() {
        while (!collision()) {
          currentY++
        }
        currentY--
        merge()
        clearLines()
        createPiece()
      }

      function clearLines() {
        let linesCleared = 0
        let clearedRows = []

        // Find all complete lines
        for (let y = ROWS - 1; y >= 0; y--) {
          if (board[y].every((cell) => cell !== 0)) {
            clearedRows.push(y)
            linesCleared++
          }
        }

        if (linesCleared > 0) {
          // Flash animation for cleared lines
          flashLines(clearedRows)

          // Remove cleared lines after animation
          setTimeout(() => {
            for (let y of clearedRows) {
              board.splice(y, 1)
              board.unshift(Array(COLS).fill(0))
            }
          }, 200)

          // Update stats
          lines += linesCleared

          // Authentic Tetris scoring system (NES version)
          // Single: 40 * level, Double: 100 * level, Triple: 300 * level, Tetris: 1200 * level
          const linePoints = [0, 40, 100, 300, 1200]
          const earnedPoints = linePoints[linesCleared] * level
          score += earnedPoints

          // Show score popup
          showScorePopup(earnedPoints, linesCleared)

          // Show combo text for multiple lines
          if (linesCleared >= 2) {
            showComboText(linesCleared)
          }

          // Pulse animation for score display
          document.getElementById('score').parentElement.classList.add('pulse')
          setTimeout(() => {
            document
              .getElementById('score')
              .parentElement.classList.remove('pulse')
          }, 500)

          level = Math.floor(lines / 10) + 1
          dropInterval = Math.max(100, 1000 - (level - 1) * 100)

          updateScore()
        }
      }

      function flashLines(rows) {
        const flashColors = ['#ffffff', '#ffff00', '#ffffff', '#ffff00']
        let flashCount = 0

        const flashInterval = setInterval(() => {
          for (let y of rows) {
            for (let x = 0; x < COLS; x++) {
              board[y][x] = flashColors[flashCount % flashColors.length]
            }
          }
          drawBoard()
          flashCount++

          if (flashCount >= 4) {
            clearInterval(flashInterval)
          }
        }, 50)
      }

      function showScorePopup(points, linesCleared) {
        const popup = document.createElement('div')
        popup.className = 'score-popup'

        const lineNames = ['', 'SINGLE!', 'DOUBLE!', 'TRIPLE!', 'TETRIS!']
        popup.textContent = `${lineNames[linesCleared]} +${points}`

        const canvas = document.getElementById('gameCanvas')
        const rect = canvas.getBoundingClientRect()
        popup.style.left = rect.left + rect.width / 2 + 'px'
        popup.style.top = rect.top + rect.height / 2 + 'px'
        popup.style.transform = 'translateX(-50%)'

        document.body.appendChild(popup)

        setTimeout(() => {
          popup.remove()
        }, 1000)
      }

      function showComboText(linesCleared) {
        const combo = document.createElement('div')
        combo.className = 'combo-text'

        const comboTexts = ['', '', 'NICE!', 'GREAT!', 'AWESOME!']
        combo.textContent = comboTexts[linesCleared]

        document.body.appendChild(combo)

        setTimeout(() => {
          combo.remove()
        }, 1000)
      }

      function updateScore() {
        scoreElement.textContent = score
        linesElement.textContent = lines
        levelElement.textContent = level
      }

      function gameOver() {
        isGameOver = true
        cancelAnimationFrame(gameLoop)
        document.getElementById('finalScore').textContent = score
        document.getElementById('finalLines').textContent = lines
        document.getElementById('gameOver').style.display = 'block'
      }

      function update(time = 0) {
        if (isPaused || isGameOver) return

        const deltaTime = time - lastTime
        lastTime = time
        dropCounter += deltaTime

        if (dropCounter > dropInterval) {
          moveDown()
        }

        drawBoard()
        drawPiece()

        gameLoop = requestAnimationFrame(update)
      }

      function startGame() {
        initBoard()
        score = 0
        lines = 0
        level = 1
        dropInterval = 1000
        isGameOver = false
        updateScore()

        document.getElementById('startBtn').style.display = 'none'
        document.getElementById('pauseBtn').style.display = 'inline-block'
        document.getElementById('gameOver').style.display = 'none'

        createPiece()
        lastTime = 0
        dropCounter = 0
        gameLoop = requestAnimationFrame(update)
      }

      function togglePause() {
        isPaused = !isPaused
        document.getElementById('pauseBtn').textContent = isPaused
          ? 'Resume'
          : 'Pause'

        if (!isPaused) {
          lastTime = 0
          dropCounter = 0
          gameLoop = requestAnimationFrame(update)
        }
      }

      function restartGame() {
        startGame()
      }

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (isGameOver || !currentPiece) return

        switch (e.key) {
          case 'ArrowLeft':
            moveLeft()
            break
          case 'ArrowRight':
            moveRight()
            break
          case 'ArrowDown':
            moveDown()
            break
          case 'ArrowUp':
            rotate()
            break
          case ' ':
            e.preventDefault()
            hardDrop()
            break
          case 'p':
          case 'P':
            togglePause()
            break
        }

        if (!isPaused) {
          drawBoard()
          drawPiece()
        }
      })

      // Mobile touch controls
      function handleMoveLeft(e) {
        e.preventDefault()
        if (isGameOver || !currentPiece || isPaused) return
        moveLeft()
        drawBoard()
        drawPiece()
      }

      function handleMoveRight(e) {
        e.preventDefault()
        if (isGameOver || !currentPiece || isPaused) return
        moveRight()
        drawBoard()
        drawPiece()
      }

      function handleMoveDown(e) {
        e.preventDefault()
        if (isGameOver || !currentPiece || isPaused) return
        moveDown()
        drawBoard()
        drawPiece()
      }

      function handleRotate(e) {
        e.preventDefault()
        if (isGameOver || !currentPiece || isPaused) return
        rotate()
        drawBoard()
        drawPiece()
      }

      function handleHardDrop(e) {
        e.preventDefault()
        if (isGameOver || !currentPiece || isPaused) return
        hardDrop()
        drawBoard()
        drawPiece()
      }

      // Draw initial empty board
      drawBoard()
    </script>
  </body>
</html>
